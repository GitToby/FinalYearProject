% !TEX root = ../main.tex

\chapter{Task Background}\label{ch:taskBackground}
This chapter will cover sections on how each part of the project will been carried out.
Useful notation is given in Section~\ref{sec:notation} however in some areas of discussion sequences are more easily denoted by explicitly describing this sequence.
Section~\ref{sec:codeTechniques} on code techniques will cover techniques used in the analysis and a walkthrough of setting up an environment to conduct similar analysis is given in Section~\ref{subsec:settingUpAResearchEnvironment}.

\section{Notation}\label{sec:notation}
Let \(S\in\{C, D\}^L\) where \(C\), \(D\) represents a cooperation, defection respectively.\(L=200\) is used throughout this report.
We can split up sequences into blocks of consecutive move elements of the same type.
We will use \(B_i\) to denote the block after \(i\) changes of move type from the explicitly stated starting move type.
\begin{itemize}
    \item Every move in a block is of the same type;
    the type is implicit based on whether \(i\) is even or not and what the starting move type was.
    \item We can use the notation \(|B_i|\) to denote the length of the \(i\)th block in the sequence.\(|B_i| \in \mathbb{Z}\)
\end{itemize}

This means we can write a sequence as a series of blocks:
\[S= B_1 B_2,\ldots,B_n\]
A Sequence can also be defined shorthand by specifying the starting move and the length of subsequent blocks:
\[S = C:\big{[}\ |B_1|,|B_2|,\ldots,|B_n|\ \big{]} \quad \Rightarrow \quad S=\overbrace{C\ldots C}^{|B_1|}\overbrace{D\ldots D}^{|B_2|}\ldots\overbrace{(C|D)\ldots (C|D)}^{|B_n|} \]
We can also construct sequences from repetitions of a sequence of blocks when it makes sense:
\[C:\big{[}\ \big{(}|B_1|,|B_2|,\ \ldots,\ |B_m|\big{)}^{k}\ \big{]} \quad \Rightarrow \quad {\small{\overbrace{C\ldots C}^{|B_1|}\overbrace{D\ldots D}^{|B_2|}\ldots\overbrace{D\ldots D}^{|B_m|}}}^{k-times}\]
The two notations can be combined to add starting and ending blocks to a repeating sequence (shown in the examples).\\

It is also possible to define sets of sequences by adding variables to parameters of the sequence.
Appropriate selection of parameters mean the length of sequences shouldn't grow.
\[ \{C:[i,l-i]\} \quad i\in [a,b] \Rightarrow \{\underbrace{C\ldots C}_{a}\overbrace{D\ldots D}^{l-a},\ \underbrace{C\ldots C}_{a+1}\overbrace{D\ldots D}^{l-(a+1)},\ldots ,\ \underbrace{C\ldots C}_{b}\overbrace{D\ldots D}^{l-b}\} \]
For long sequences where there is no recognisable pattern it is typically easier to describe the solution.
Otherwise we use the notation to describe a sequence.\\
Examples:
\begin{align}
    C:[1,4,3,2] &= CDDDDCCCDD\\
    D:[\ (1,1)^{5}] &= DCDCDCDCDC\\
    C:[1,(2,1)^{2},2,1] &= CDDCDDCDDC\\
    \{D:[i,5-i]\} \quad i\in [2,4] &= \{DDCCC,\ DDDCC,\ DDDCC\}\\
\end{align}

\section{Solution Form}\label{sec:solutionForm}
In this research our goal will be to use the algorithm, described in Subsection~\ref{subsec:geneticAlgorithms}, to produce an arbitrary sequence for an opponent, \(S_o\).
This sequence will represent the moves we should play against the opponent to get our largest potential score per turn for a single game of 200 turns.\\

This investigation focuses on sequences that will allow us to maximise our score overall, rather than just beating any given opponent.
An analogy of this concept is a team playing a football tournament, but instead of a knockout competition our team is placed in the standings based off the total goals they have scored across the tournament.
More real world applications of these results are discussed in Chapter~\ref{ch:applications}.\\

Each solution sequence is uniquely generated for each opponent.
If there are two similar opponents, say Grudger and Collective Strategy, these will be independently analysed and individual solutions will be generated.
The output sequences will be compared on how similar they are to each other, what type of opponents and their corresponding `best scores' are and whether there are patterns to how to group strategies, Chapter~\ref{ch:results} contains further details.\\

When working with stochastic players, we will be seeding them in order to determine the best sequence.
Each stochastic player will be considered under a variety of seeds.
The motive to allow this to happen is explained described in Section~\ref{sec:stochasticOpponents}.Non-stochastic opponents will be seeded in the code, however there is no change in their behaviour because of this.

\section{Development Practices}\label{sec:codeTechniques}
This section will discuss how we will leverage code to complete aspects of the investigation.
We will be using Python because of its flexibility and it is the language the required libraries are written in.

\subsection{Building The Algorithm}\label{subsec:buildingTheAlgorthem}
In order to generate a solution sequence we have to train against each Axelrod opponent against another Axelrod opponent.
We will use the Cycler strategy\footnote{See Section~\ref{subsec:cycler} for description} in the algorithm by editing the input parameter to improve our score against an opponent.\\

Our implementation of a genetic algorithm is more custom and has the following steps:
\begin{enumerate}
    \item Start with a predefined population, supplemented with randomly generated member until to size.
    \item Each member plays the given opponent with their sequence and returns with the average score per turn.
    \item Members of the population are ranked by this average score per turn and the highest scoring 25\% will be kept for the next round.
    The remaining 75\% are killed off.
    \item The remaining population will then be copied and these copies mutated to create unique sequences before being merged back in to the main population.
    \item The remaining 50\% difference is then made up of mutated results of crossovers from members of the current population or random new members, depending on a random selection algorithm.\footnote{This algorithm had a bug which would change the size of the population in the first generation.
    This was fixed after Section~\ref{sec:conclusionOfApproach} was written.
    See: https://github.com/Axelrod-Python/axelrod-dojo/issues/43}
    \item A generation has now concluded.
    Repeat from step 2 until the desired number of generations are finished and a final best sequence is returned.
\end{enumerate}
Figure~\ref{fig:geneticAlgoCycle} shows a flow diagram of our cycle.
This is the algorithm we will use in Chapter~\ref{ch:implementation} when analysing the algorithms parameters\\

\begin{figure}[h]
    \includegraphics[width=1.0\textwidth, center]{./img/flows/custom_ga_cycle}
    \caption{High Level Genetic Algorithm Cycle}\label{fig:geneticAlgoCycle}
\end{figure}

This model means we can create a population of Cycler players and input a sequence of length 200 as a parameter to set off our genetic algorithm.
The subsequent inputs for the populations Cycler players will be created using the genetic mutation and crossover techniques, see Section~\ref{subsec:geneticAlgorithms} for details.\\

The flow of Play-Rank-Create looping (see Figure~\ref{fig:geneticAlgoCycle}) will be the basis of creating the optimal strategy for each other opponent.
Each step is defined in the Axelrod-Dojo librarys' Population and CyclerParams classes.
Rather than store all the functionality in one place we are able split up aspects of the flow to allow for flexibility in what type of population can be used.

\subsection{Conducting analysis}\label{subsec:conductingAnalysis}
For the analysis a mix of Jupyter Notebooks and IDE\footnote{Pycharm Professional Edition and Microsoft VS Code.} development were used.
The main analysis was run using a factory class, written by me, called `full\_analysis'.
This class was used to wrap a query to the Axelrod-Dojo functionality and subsequently to the Axelrod Library in such a way that was easy to control batch executions.\\

The analysis itself was done using native multi-threading on a Linux OS to improve individual opponent analysis run times and the overall scalability of the project.
This will be discussed further in Subsection~\ref{subsec:settingUpAResearchEnvironment}.

\subsubsection{Libraries And Codebases}
\paragraph{Main Research Libraries}
\begin{itemize}
    \item \textbf{Axelrod} --- Used for the core of the prisoners dilemma and iterated prisoners dilemma functionality code.
    \item \textbf{Axelrod-Dojo} --- Applied machine learning techniques that revolve around generating solutions to questions relating to the Axelrod library.
\end{itemize}

\paragraph{Functional libraries}
Table~\ref{table:functionalLibrares} shows the functional libraries used.
These are libraries which are not involved in the core functionality of the IPD\@.
\begin{table*}[h]
    \centering
    \begin{tabular}{cc}
        \toprule
        Library & Reason\\
        \midrule
        \textbf{os} & For operating system functionality.\\
        \textbf{time} & For time calculations.\\
        \textbf{matplotlib pyplot} & For plotting graphs and images with data\\
        \textbf{pandas} & For data manipulation.\\
        \textbf{numpy} & For reducing complexity of numerical calculations.\\
        \textbf{itertools} & For easier iterations over data structures.\\
        \bottomrule
    \end{tabular}
    \caption{Functional Python libraries for analysis}\label{table:functionalLibrares}
\end{table*}

\subsection{Setting Up A Research Environment}\label{subsec:settingUpAResearchEnvironment}
This section will go into detail on the set up and reasoning behind using specific development environments.This tutorial will also assume you're working with a local development station;
analysis on remote cloud instances of Jupyter Notebooks is possible but the set up is different.

\paragraph{Installing Basic Libraries}
Your first step should be to download and install the Anaconda distribution for your OS here: https://www.anaconda.com/download/.
This will allow you to use the integrated c++ libraries python has to offer without needing to mess about too much.
Anaconda also has them majority of Functional Libraries above and Jupyter Notebooks pre installed to make setting up much easier.
From here, follow the instructions the install wizard has to add any environment variables to allow CMD/Bash access to binaries.\\ 

Installing the Axelrod and Axelrod-Dojo libraries uses the pip tool that already comes with Anaconda and should be ready to execute after the last step.Running `pip install axelrod' then `pip install axelrod-dojo' will install these.\\

Once this is installed the `full\_analysis.py' file has to be downloaded from github: https://github.com/GitToby/FinalYearProject in the `code' directory.This can just be copied and pasted if needed all were interested in is the class to generate a sequence for an opponent.

\paragraph{Running a Test}
Figure~\ref{code:analysisExample} is some sample code that will run an analysis with the following settings
\begin{itemize}
    \item Override the default mutation frequency of \(0.1\) to \(0.3\).
    \item Set the prefix for all the files to be `example-'.
    \item Analysing 3 opponents.(Random will have multiple instances for different seeds.) 
\end{itemize}
\begin{figure}[h]
    \centering
    \inputminted{python}{code_snippets/analysisExample.py}
    \caption{Code to create a sequence result to optimise best score for 3 opponents}\label{code:analysisExample}
\end{figure}

After it has run the output should be stored in the `./output' directory.
If the code fails to run there may be issues with this directory being created.
There should be multiple output files, each with one opponents evolution stages through the generations.

\paragraph{Cloud Notebook Setup} 
If you want to use a Cloud service, such as Azure Notebooks or AWS Sagemaker, the set up is similar to the above just executed differently.
Installing Anaconda is not needed, the environment has the required installs.
Using pip to install the Axelrod libraries and download the full analysis script can be done in an integrated web terminal or directly in a notebook.
Figure~\ref{code:jupyterExample} shows and example in azure, copy these in your top few cells of your jupyter notebook and it will work as required.

\begin{figure}[h]
    \centering
    \inputminted{python}{code_snippets/jupyterCells.py}
    \caption{Cells for creating the jupyter instance of a research environment}\label{code:jupyterExample}
\end{figure}