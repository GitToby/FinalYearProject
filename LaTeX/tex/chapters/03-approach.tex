% !TEX root = ../main.tex

\chapter{Task Background}\label{ch:taskBackground}
% TODO split into 2 chapters: {Task Background & Tuning of Genetic Algorithm}
In this chapter, consideration will be given to the process of finding the optimal sequence of moves against another player.
The various approaches used and a detailed analysis of the optimisation procedures and parameters will be described.\\

{\itshape~When playing a given Iterated Prisoners Dilemma strategy, \(O\), what is the best ordered sequence of moves, \(S\), to play such for us to obtain the highest possible average score per move across the game.}\\

This investigation will only be looking into games against one opponent.
We will not differentiate the solution form or technique for finding a solution depending on the type of opponents we are focusing on.
Each opponent will be investigated independently of each other and have their own report generated.


\section{Notation}\label{sec:notation}
Let \(S\) be a sequence composed of move elements: \(S = X_1 X_2 \ldots X_L\).
\begin{itemize}
    \item \(X_i=C\) is a cooperation type move element
    \item \(X_i=D\) is a defection type move element.
    \item \(X_i\) denotes the \(i\)th move element in a sequence, \(X_i \in \{C,D\}\).
    \item \(L\) denotes the length of a sequence; \(L=200\) is used throughout this report.
\end{itemize}

We can split up sequences into blocks of consecutive move elements of the same type.
We will use \(B_i\) to denote the block after \(i\) changes of move type from the explicitly stated starting move type.
\begin{itemize}
    \item Every move in a block is of the same type;
    the type is implicit based on whether \(i\) is even and what the starting move type was.
    \item We can use the notation \(|B_i|\) to denote the length of the \(i\)th block in the sequence. \(|B_i| \in \mathbb{Z}\)
\end{itemize}

This means we can write a sequence as a series of blocks:
\[S= B_1 B_2,\ldots,B_n\]
A Sequence can also be defined shorthand by specifying the starting move and the length of subsequent blocks:
\[S = C:\big{[}\ |B_1|,|B_2|,\ldots,|B_n|\ \big{]} \quad \Rightarrow \quad S=\overbrace{C\ldots C}^{|B_1|}\overbrace{D\ldots D}^{|B_2|}\ldots\overbrace{(C|D)\ldots (C|D)}^{|B_n|} \]
We can also construct sequences from repetitions of a sequence of blocks when it makes sense:
\[C:\big{[}\ \big{(}|B_1|,|B_2|,\ldots,|B_m|\big{)}^{k}\ \big{]} \quad \Rightarrow \quad {\small{\overbrace{C\ldots C}^{|B_1|}\overbrace{D\ldots D}^{|B_2|}\ldots\overbrace{D\ldots D}^{|B_m|}}}^{k-times}\]
The two notations can be combined to add starting and ending blocks to a repeating sequence (shown in the examples).\\

It is also possible to define sets of sequences by adding variables to parameters of the sequence.
Appropriate selection of parameters mean the length of sequences shouldn't grow.
\[ \{C:[i,l-i]\} \quad i\in [a,b] \Rightarrow \{\underbrace{C\ldots C}_{a}\overbrace{D\ldots D}^{l-a},\ \underbrace{C\ldots C}_{a+1}\overbrace{D\ldots D}^{l-(a+1)},\ldots ,\ \underbrace{C\ldots C}_{b}\overbrace{D\ldots D}^{l-b}\} \]
For long sequences where there is no recognisable pattern the wildcard \(*^{j}\) may be used.
This is to signify that \(j\) consecutive move elements have no pattern and are randomly distributed.
We will mainly use this when referring to sections of a sequence that would otherwise be too lengthy to write out.\\

Examples:
\[ C:[1,4,3,2] = CDDDDCCCDD \]
\[ D:[\ (1,1)^{5}] = DCDCDCDCDC \]
\[ C:[1,(2,1)^{2},2,1] = CDDCDDCDDC \]
\[ \{D:[i,5-i]\} \quad i\in [2,4] = \{DDCCC,\ DDDCC,\ DDDCC\}\]

\section{Solution Form}\label{sec:solutionForm}
Our algorithm will, after its set number of generations have concluded, produce an arbitrary sequence of the form:
\[X_1,X_2,X_3,\ldots ,X_n \textrm{ where }  X_i \in {C,D}\]
This sequence will be represent what moves we should play against the opponent to get our largest potential score per turn.\\

We are looking for sequences that will allow us to maximise our score overall, rather than just beating any given opponent.
A nice analogy of this concept is a team playing a football tournament, but instead of a knockout competition our team is placed in the standings based off the total goals they have scored across the tournament.
More applications of these results are discussed in Chapter~\ref{ch:applications}.\\

\section{Code Techniques}\label{sec:codeTechniques}
The sequence archetype will use the \(Cycler()\) player for our strategy each time, only editing the input parameter to improve our score against an opponent.
To this model we can apply an optimised input of length 200 to the player, this sequence, as per the design of the strategy will then be repeated until the games end (if n = length of game, we are just calculating the sequence for the whole game).
The input sequence itself will be created using a genetic optimisation, see Section~\ref{subsubsec:geneticAlgorithms} for in depth
explanations.\\

This sequence of Play-Rank-Create-LOOP will be the basis of creating the optimal strategy for each other opponent.

